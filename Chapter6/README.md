## * UDP client, server 구현   
#### * 출처 : 윤성우 TCPIP   
#### * 사용환경 : 우분투 16ver   

#### * UDP 특성   
			1. 일방향성
			2. 데이터 분실 및 손실 위험
			3. 메시지 전달 제어기능 없음
			4. 데이터 전송이 빠르지만 수신자가 못 받을 가능성이 있다.   

#### * UDP 데이터 송, 수신   
			1. 연결의 개념이 존재하지 않기 때문에 서버 및 클라이언트 소켓 구분이 없다.	
			2. 하나의 소켓으로 2개 이상의 송, 수신이 가능하기 때문에 수신 후 전송지가 어디인지 확인 할 필요가 있다.
			3. 데이터를 전송할 때 마다 목적지 정보를 전송해야 한다.   

#### * 데이터의 경계가 존재하는 UDP   
			* TCP : 긴 데이터 메시지를 한 번에 보내지 못할 때 -> 쪼개서 전송한다.(단편화)
					* 단편화 : 보낸 데이터를 전부 전송받지 못 하는 경우가 생기기 때문에 데이터 수신을 누적하는 방식으로 해결한다.
					* 전송 받은 데이터 사이즈 == 누적 데이터 사이즈   => 충족 시 loop를 빠져나온다.
					* 이는 데이터에 경계가 존재하지 않는 것을 의미한다.   
			* UDP : 이러한 개념 없이 전송하는 데이터를 그대로 한 번에 전송한다. => 데이터 손실 우려 

#### * client에서의 sendto() 함수   
			* 호출 시 localhost의 IP와 임의의 Port 정보가 자동으로 할당된다.
			* 때문에 bind() 함수가 필요 없어지며 코드가 간결해진다.   


#### * server에서의 recvfrom() 함수   
			* 하나의 데이터를 한 번에 읽어들인다.
			* 기존의 TCP구조는 전송하는 데이터의 손실을 우려하여 데이터 단편화를 통해 해결했다.
			* 이는 TCP 통신 구조에 데이터의 경계가 존재하지 않음을 의미하지만 
			* UDP에서는 한 번에 데이터를 보내거나 받기 때문에 데이터의 경계가 존재함을 알 수 있다.   

#### * server에서의 bind() 이유   
			* 누군가 자신에게 데이터를 전송하기 위해서는 주소 정보(IP, Port)가 필요하기 때문이다.

#### * sendto() 함수   
			* 목적지 주소정보(서버에서 bind()를 통해 할당한 주소 정보)를 인자로 전달한다.

```c
ssize_t sendto(int sock, void *buff, size_t nbytes, int flags, struct sockaddr *to, sockaddr_t addrlen);

```   
			* sock : 데이터 전송에 사용될 UDP 소켓의 파일 디스크립터
			* buff : 전송할 데이터를 저장하는 버퍼의 주소 값 전달
			* nbytes : 전송할 데이터의 크기, 바이트 단위로 전달한다.
			* flags : 옵션 지정에 사용되는 매개변수, 지정 옵션이 없으면 0을 전달한다.
			* to : 목적지 주소정보를 담고있는 sockaddr 구조체 변수의 주소 값을 인자로 전달
			* addrlen : to로 전달된 주소 값의 구조체 변수의 크기를 인자로 전달한다.  


#### * recvfrom() 함수   
			* 송신자 주소 정보를 할당한다.
			* 어디로든 데이터를 받을 수 있는 송신자가 불분명한 상황이기 때문에 데이터 수신 시 어디로부터 수신되었는지에 대한 정보를 확인 가능하다.

```c
ssize_t recvfrom(int sock, void *buff, size_t nbytes, int flags, struct sockaddr *from, socklen_t *addrlen);
```   
			* sock : 데이터 수신에 사용될 UDP 소켓의 파일 디스크립터
			* buff : 수신에 사용될 버퍼의 주소 값
			* nbytes : 수신할 최대 바이트 수 전달, buff가 가리키는 버퍼의 크기를 넘을 수 없도록 한 것
			* flags : 옵션 지정에 사용되는 매개변수
			* from : 발신지 정보를 저장 할 sockaddr 구조체 변수의 주소 값 전달
			* addrlen : from으로 전달된 주소 값의 구조체 변수 크기   

#### * sendto()/recvfrom() 과 write()/read() 함수의 차이점   

1. 함수 호출 시 목적지 정보를 반드시 전달하게 되어있다.
2. read()/write() : 목적지 정보가 이미 결정된 경우에 사용 
3. sendto()/recvfrom() : 송, 수신 데이터에 대한 주소 정보를 확인할 때 사용   

#### * bound_host1.c sleep(5) 이유   
			* 수신 받은 데이터가 한 번에 버퍼로 전부 저장되는지 확인하기 위함이다.
			* 즉, 데이터의 경계가 존재하는가에 대해 확인하기 위함   

```c
for(i=0; i<3; i++)
{
	sleep(5);	// delay 5 sec.
	adr_sz=sizeof(your_adr);
	str_len=recvfrom(sock, message, BUF_SIZE, 0, 
							(struct sockaddr*)&your_adr, &adr_sz);     
	
	printf("Message %d: %s \n", i+1, message);
}
```   

#### * connected UDP   
			* 기존에는 sendto()를 사용하여 주소가 묶여있었지만, connect() 함수를 사용하여 주소를 분리시켰다.
			* 데이터 송, 수신에 read(), write() 함수를 사용한다. -> 주소를 설정하지 않아도 되는 편리함
			* connect() : 실제 상대방에게 연결을 요청하는 동작이 아닌 목적지에 해당하는 IP와 Port 정보를 기록만 해두는 역할로만 사용된다.
			* 이를 통해 read(), write() 함수 호출로 데이터 송, 수신이 가능해졌다.
			* sendto() 같은 경우에는 어디로 데이터를 보내거나 어디에서 받는가에 대한 확인하기 위한 함수다.
			* 목적지 정보가 이미 결정이 된 경우에는 read(), write() 함수를 호출하여 사용할 수 있다.
